
# Lua 常见 web 漏洞 #


云化场景下，lua 脚本广泛应用于服务器逻辑处理，如何确保 lua 脚本的安全性成为了至关重要的话题。

nginx + lua  (openresty)  
apache + lua   (mod_lua)  
cgilua (特殊)     ( <? code ?> )

本文主要使用了 openresty 的环境进行验证  
[漏洞类型](## 漏洞类型)  
[writeup](## writeup)  
[TODO](## TODO)


## 漏洞类型 ##

### 1.xss ###

**如果直接返回在浏览器中的内容用户可控，则存在 xss 的风险**

1.内部接口（不直接回显在浏览器）基本无风险，但也要关注用户可控数据是否通过其他接口外带至浏览器及前端是否做 xss 防护。

**关键函数**
```
ngx_lua: ngx.say(), ngx.print()
mod_lua: r:puts(), r:write()
CGILua: cgilua.put(), cgilua.print()
```

**漏洞代码**
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local content = obj["content"]
ngx.say(content)
```

**正确处理方式**  
1.对可能造成 xss 的字符进行 html 转义  
2.设置cookie httponly  
3.添加 X-XSS-Protection: 1; mode=block 头 *

<br>

### 2.sql注入 ###
**如果在进行数据库操作时没有正确处理用户请求数据，导致用户数据被直接拼接进 sql 语句中，则存在 sql 注入的风险**  
**关键函数**
```
LuaSQL : conn:execute()
mod_lua : DB API：db:query()
ngx_lua : require("resty.xxxx") ,db:query()
```
上述的关键函数仅为举例，无法做到很强的普适性。sql 注入这一块需要识别应用是否有数据库操作，如果有需要检视数据库操作过程。

**漏洞代码**
```
local obj = cjson.new().decode(args)
local username = obj["username"]
local password = obj["password"]
local query = [[SELECT * FROM user1 WHERE username='%s' AND password='%s' limit 1]]
query = string.format(query, username, password)
local res,err,errno,sqlstate= db:query(query)
if not (res ==nil or next(res)==nil) then
    local username = res[1].username
    local password = res[1].password
    if username == "admin" and password == "admin" then
        ngx.say("login success")
    end
else
    ngx.say("login failed")
end
```

**正确处理方式**  
使用预编译而不是直接拼接 sql 语句

<br>

### 3.命令注入 ###
**如果未经过校验的用户数据被传入执行系统命令的函数中，则存在命令注入的风险**
**关键函数**
```
io.popen()  
os.execute()  
```
**漏洞代码**
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local cmd = obj["cmd"]
cmd = "ls " .. cmd
local result = io.popen(cmd)
ngx.say(result:read("*a"))
result:close()
```

**正确处理方式**  
1.尽量不要直接使用命令执行函数，使用其他功能函数代替  
2.如果使用命令执行函数，需要对外部可控数据进行校验（白名单为优）

<br>

### 4.文件操作 ###

**如果未经过校验的用户数据被传入文件操作函数中，则存在文件系统攻击的风险**
**关键函数**
```
Lua io 库：io.open(), ...
LuaFileSystem (lfs) 库函数 https://lunarmodules.github.io/luafilesystem/
mod_lua: r:mkdir(), r:mkrdir(), r:rmdir(), r:sendfile(), r:touch()
```
#### 目录穿越 ####
**漏洞代码**
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local file = obj["filename"]
-- read_file 为定义的文件读取函数，调用了 io.open
local content, err = read_file("/usr/local/work/files/".. file)
ngx.say(content)
```

#### 目录截断 ####
**Lua 由 c 语言编写而成，其文件系统函数在接受包含空字符(%00)(\x00) 参数时，会将空字符视为字符串的终止符并忽略后续字符，这点和 php(version<5.3.4) 很像**  
**漏洞代码**
```
local file = ngx.req.get_uri_args()["filename"]
-- read_file 为定义的文件读取函数，调用了 io.open
local content, err = read_file("/usr/local/work/files/".. file .. ".txt")
ngx.say(content)
```

因为篇幅问题，此处只介绍这两种可能造成文件攻击的问题
思考：（下列代码是否会造成目录穿越，原因是？）
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local file = obj["filename"]
local content, err = read_file("/home/www/".. file .. ".txt")
ngx.say(content)
```

**正确处理方式**  
在进行文件操作时，对外部传入的数据进行校验

<br>

### 5.文件包含 ###
**如果代码中导入的内容为外部用户可控，则存在文件包含的风险**
**关键函数**
```
Lua : require(), dofile()
CGILua : cgilua.handlelp(),cgilua.lp.include(),cgilua.doif(),cgilua.doscript()
```
**漏洞代码**
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local content = obj["content"]
content = [[
local _M ={}
function _M.execute()]] .. content .. [[
end
return _M]]
-- write_file 为定义的文件写函数，调用了file:write
local res = write_file("/home/www/lua/mod1.lua", content)
if res == "success" then
  package.path = package.path .. ";/home/www/lua/?.lua"
  local mod1 = require "mod1.lua"
  mod1.execute()
else<br>
  ngx.say(res)
end
```

**正确处理方式**  
严格限制外部用户可控内容

<br>

### 6.代码注入 ###
**loadstring() 函数将编译代码并返回一个函数(类似 python 和 php 的 eval 函数)，如果该函数的参数为外部可控，则存在代码注入的风险**
**关键函数**
```
Lua : loadstring
CGILua : cgilua.lp.translate(),cgilua.handlelp(),cgilua.doif()
```
**漏洞代码**
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local code = obj["code"]
if code == nil or #code==0 then
    code = "ngx.say('Hello lockcy')"
end
local res,err = pcall(function()
    loadstring(code)()
end)
if err ~=nil then
    ngx.say(err)
end
```

**正确处理方式**  
严格限制外部用户可控内容

<br>

### 7.不安全哈希算法 ###
**对敏感信息做单向哈希时，如果使用 MD5 SHA1 等不安全的散列算法，存在被破解的风险**
**关键函数**
```
require "resty.md5"
require "resty.sha1"
……
```
这里列举两种针对不安全哈希算法的攻击方式
#### 弱密码碰撞 ####
**漏洞代码**
```
local args = ngx.req.get_body_data()
local obj = cjson.new().decode(args)
local password = obj["password"]
local cipher1 = md5.sumhexa(password)
if cipher1 == "197bc9f7ae368b5016cf80f44993ac10" then
    local content, err = read_file("/flag")
    ngx.say(content)
end
```
#### 长度扩展攻击 ####
**漏洞代码**
```
local username = ngx.req.get_uri_args()["username"]
if username == nil then
    username = ""
end
local key = "**************"
local timestamp = ngx.time()
local cipher1 = md5.sumhexa(key .. timestamp .. username)
ngx.say(cipher1)
if cipher1 == hash then
    local content, err = read_file("/flag")
    ngx.say(content)
end
```

**正确处理方式**  
使用相对安全的哈希算法，如PBKDF2

<br>

### 8.弱匹配模式 ###
**如果使用弱模式匹配函数进行校验，则存在绕过输入校验的风险**
**关键函数**
```
string.match()
```
**漏洞代码**
```
local email = ngx.req.get_uri_args().email or ""
ngx.header.content_type = "text/html"
if email:match("[A-Za-z0-9%.%%%+%-]+@[A-Za-z0-9%.%%%+%-]+%.%w%w+") then
  ngx.say(email)
end
```
**正确处理方式**  
1.弱模式匹配时使用完整正则  
![match.png](image/match.png)

![match1.png](image/match1.png)

2.使用包含允许使用PCRE (Perl Compatible Regular Expressions)的模式匹配函数的 Lua 库，如：
```
Apache mod_lua: r:strcmp_match(),r:regex(),r:expr()
Nginx ngx_lua: ngx.re.match()
```

<br>

### 9.文件上传 ###
这边尝试使用 %00 截断(同 php)，但没有达到预期的效果。
lua 比较字符串逻辑(比较哈希值)

<br>

### 10.弱类型引发的问题 ###
lua 串联运算时会强制将数字转换为字符串
```
print("This is Lua version " .. 5.1 .. " we are using.")
output >> This is Lua version 5.1 we are using.
print("Pi: " .. math.pi)
output >> Pi: 3.1415926535898
print("Pi: " .. 3.1415927)
output >> Pi: 3.1415927
```
在考虑转换方式时，开发者应当尽可能避免使用强制转换。虽然强制转换有一定成效，但并非是最佳实践方法
```
print(100 + "7")
output >> 107
```
比较运算符（也就是 ==、~=、<、>、<= 和 >=）无法强制转换其参数
```
print(100 == "100")
output >> false
```

<br>

### 其他场景 ###
1.Lua 脚本配合 openresty 主要用于认证鉴权、在不破坏原有业务代码的情况下处理附加逻辑；因此需要重点关注认证鉴权时潜在的越权风险或逻辑问题  
2.需要关注 服务器组件 、 lua 、中间件存在的 CVE  
[Apache mod_lua 缓冲区溢出漏洞](https://www.venustech.com.cn/new_type/aqldfx/20220120/23400.html)  
[Lua CVE](cvedetails.com/vulnerability-list/vendor_id-13641/LUA.html)  
[redis_lua_exploit](github.com/QAX-A-Team/redis_lua_exploit)

<br>

参考资料  
https://httpd.apache.org/docs/current/en/mod/mod_lua.html
https://moonbingbing.gitbooks.io/openresty-best-practices/content
http://www.lua.org/manual/5.1/manual.html#2.2.1
